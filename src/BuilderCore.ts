/**
 * @author Adam Josefus
 */

import { join } from "https://deno.land/std@0.136.0/path/mod.ts";
import * as esbuild from 'https://deno.land/x/esbuild@v0.14.27/mod.js';
import { type ConfigType } from "./parseConfig.ts";
import { brightRed as red, yellow, green, gray } from 'https://deno.land/std@0.136.0/fmt/colors.ts';
import * as print from "./stylePrint.ts";
import { pipe } from "./pipe.ts";


export type OptionsType = Partial<{
    bundle: boolean,
    minify: boolean,
    sourcemap: boolean,
}>;


export class BuilderCore {

    #config: ConfigType;

    #buildOptions: esbuild.BuildOptions;

    #isRunning = false;
    #programInterruptToggle = false;


    constructor(entryPoints: string[], config: ConfigType) {
        this.#config = config;

        const watchMode: esbuild.WatchMode = {
            onRebuild: (failure, results) => {
                if (results?.stop) results.stop()

                if (this.#programInterruptToggle) return;

                if (failure) {
                    this.#onFailure(failure.errors ?? [], failure.warnings ?? []);
                    return;
                }

                const errors = results?.errors ?? [];
                const warnings = results?.warnings ?? [];
                const metafile = results?.metafile ?? null;

                if (metafile === null) throw new Error("Metafile is null");

                this.#onBuild(errors, warnings, metafile);
            }
        }

        this.#buildOptions = {
            entryPoints,
            outdir: config.outDir,
            bundle: config.build.bundle,
            minify: config.build.minify,
            sourcemap: config.build.sourcemap,
            tsconfig: config.options.tsconfig ?? undefined,
            charset: 'utf8',
            target: ['es2020'],
            loader: {
                '.ts': 'ts',
                '.js': 'js',
            },
            watch: config.options.watch ? watchMode : false,
            metafile: true
        }
    }


    #beforeStart() {
        this.#isRunning = true;

        const { bundle, minify, sourcemap } = this.#config.build;

        print.text``;
        print.headline`${green(`Building...`)}`;

        if (this.#config.options.verbose) {
            print.bullet`Bundle:     ${bundle ? green('Yes') : yellow('No')}`;
            print.bullet`Minify:     ${minify ? green('Yes') : yellow('No')}`;
            print.bullet`Source map: ${sourcemap ? green('Yes') : yellow('No')}`;

            print.note`----------------`;
        }

        if (this.#config.options.watch) {
            print.note`Watching...`;
        }

        print.text``;
    }


    #afterStop() {
        print.text``;
        print.note`Stopped.`;
        print.text``;

        esbuild.stop();
    }


    async #onBuild(warnings: esbuild.Message[], errors: esbuild.Message[], metafile: esbuild.Metafile) {
        const now = new Date();
        const time = [
            now.getHours().toString().padStart(2, '0'),
            now.getMinutes().toString().padStart(2, '0'),
            now.getSeconds().toString().padStart(2, '0'),
        ].join(':');

        print.bullet`${green(`Built`)} ${gray('-')} ${time}`;

        this.#printErrors(errors);
        this.#printWarnings(warnings);


        if (this.#config.options.verbose) {
            console.log(gray(await esbuild.analyzeMetafile(metafile!)));
        }

        if (this.#config.options.gitignore) {
            this.#generateGitignore(metafile);
        }

        if (this.#config.options.outputSummar) {
            this.#generateSummary(metafile);
        }
    }


    #onFailure(warnings: esbuild.Message[], errors: esbuild.Message[]) {
        this.#printErrors(errors);
        this.#printWarnings(warnings);
    }


    #generateGitignore(metafile: esbuild.Metafile) {
        const records = Object.entries(metafile.outputs)
            .map(([path, _info]) => join(this.#config.outDir, '..', path))
            .map(path => path.replace(this.#config.outDir, ''))
            .map(path => join('./', path));

        if (this.#config.options.outputSummar) {
            records.push('');
            records.push(`# Output summary`);
            records.push(join('./', this.#config.options.outputSummaryFilename));
        }

        records.push('');
        records.push('!.gitignore');

        records.unshift(
            '########################',
            '# Generated by Builder #',
            '########################',
            '',
        );

        records.push('');

        const gitignorePath = join(this.#config.outDir, '.gitignore');
        Deno.writeTextFileSync(gitignorePath, records.join('\n'));
    }


    #generateSummary(metafile: esbuild.Metafile) {
        const clean = (path: string, base: string) => {
            return pipe<string>(
                s => join(base, '..', s),
                s => s.replace(base, ''),
                s => join('./', s),
            )(path);
        }

        const compilerOutput = Object.entries(metafile.outputs)
            // Clean paths
            .map(([path, info]) => ({
                path: clean(path, this.#config.outDir),
                entryPoint: info.entryPoint ? clean(info.entryPoint, this.#config.sourceDir) : null
            }))
            // Add entryPoint to sourcemap files
            .map((output, _i, arr) => {
                // Has own origining entry point. It is not a sourcemap file.
                if (output.entryPoint !== null) return output;

                const origin = arr.filter(o => o.entryPoint).find(o => `${o.path}.map` === output.path);
                if (!origin) return output;

                return {
                    path: output.path,
                    entryPoint: origin.entryPoint
                }
            });

        const data = this.#config.files
            .map(({ path, group }) => {
                const x = compilerOutput.filter(o => o.entryPoint === path);

                return x.map(x => ({
                    path: x.path,
                    group
                }));
            })
            .flat()
            .reduce((sets, v) => {
                const key = v.group ?? null;

                if (sets.has(key)) sets.get(key)!.push(v.path);
                else sets.set(key, [v.path]);

                return sets;
            }, new Map<string | null, string[]>());


        const content: string = (() => {
            const ungrouped: string[] = [...data.entries()]
                .filter(([group, _paths]) => group === null)
                .map(([_group, paths]) => paths)
                .flat()
                .filter((v, i, arr) => arr.indexOf(v) === i);

            const grouped: Record<string, string[]> = [...data.entries()]
                .filter(([group, _paths]) => group !== null)
                .reduce((sets, [group, paths]) => {
                    const g = group!;

                    if (sets[g]) sets[g].push(...paths);
                    else sets[g] = paths;

                    return sets;
                }, {} as Record<string, string[]>);

            const files = ungrouped.length > 0 ? ungrouped : grouped;

            return JSON.stringify({
                version: this.#config.version,
                files: files,
            }, null, '    ');
        })();

        const file = join(this.#config.outDir, this.#config.options.outputSummaryFilename);
        Deno.writeTextFileSync(file, content);
    }


    #printWarnings(warnings: esbuild.Message[]): void {
        warnings.forEach(message => {
            const { pluginName, text, location, notes } = message;

            print.bullet`${yellow(text)}`;
            print.subbullet`${gray(Deno.inspect({ pluginName, location, notes }))}`
        });
    }


    #printErrors(errors: esbuild.Message[]): void {
        errors.forEach(message => {
            const { pluginName, text, location, notes } = message;

            print.bullet`${red(text)}`;
            print.subbullet`${gray(Deno.inspect({ pluginName, location, notes }))}`
        });
    }


    async start() {
        this.#beforeStart();

        const results = await esbuild.build(this.#buildOptions);

        const errors = results?.errors ?? [];
        const warnings = results?.warnings ?? [];
        const metafile = results?.metafile ?? null;

        if (metafile === null) throw new Error("Metafile is null");

        await this.#onBuild(errors, warnings, metafile);

        if (!this.#config.options.watch) {
            this.stop();
        } else {
            Deno.addSignalListener('SIGINT', () => {
                this.#programInterruptToggle = true;
                this.stop();
            });
        }
    }


    stop() {
        if (!this.#isRunning) return;
        this.#isRunning = false;

        this.#afterStop();
    }
}
